---
layout: post
title: "chronos"
---

# chronos research note

##  1.概述

chronos是一个使用一个ap点来实现分米级的定位系统。主要的工作是解决如何准确的计算出AP和client之间信号的time-of-flight。得到time-of-flight之后然后再乘以光速得到AP和client之间的距离。（time-of-flight以下简称TOF）

> 补充一个基础知识
>
> 在某个频带上计算time-of-flight
>
> ####                                                                                                         $h=ae^{-j2\pi ft}$                       1-1
>
> ​                      $\angle h= -2\pi f\tau mod2\pi $                       1-2
>
> ​                      $ \tau = \frac{\angle h}{2\pi f} mod \frac{1}{f}$                                  1-3
>
> 其中$\tau$表示TOF。由公式1-3可以得知，TOF算出来肯定是个周期值。这个值我们是没法用的。例如在2.41GHZ的频带上计算出的TOF如下图所示：
>
> ![单个频带计算time-of-flight](D:\yanjiang0216.github.io\_posts\单个频带计算time-of-flight.png)

##2.chronos如何计算TOF

在多个频带下计算出的TOF。如下图所示

![在不同频带上计算出的time-of-flight](D:\yanjiang0216.github.io\_posts\在不同频带上计算出的time-of-flight.png)

从上图可以看出，在一对AP和client之间的多个频带上同时计算TOF，总会有一个TOF满足所有频带。那么这个TOF就是我们所要的TOF。那么如何计算出这个TOF呢？咱们先暂时不管一些误差和多径问题，只是单纯地讨论如何计算出这个TOF。**遇到两个问题：1.wifi信号没有连续的的宽带宽。2.在多个1-3公式中，如何解出这个TOF值。**

### 2.1问题1

wifi信号虽然没有很高的带宽，但是wifi信号在2.4Ghz和5Ghz周围有写不连续的带宽。如下图所示。

![wifi频带](D:\yanjiang0216.github.io\_posts\wifi频带.png)

利用这个特点我们可以通过扫频来模拟高带宽。

**扫频**

前面我们提到wifi信号在2.4Ghz和5Ghz周围有很多不连续的频带，扫频就是在这些频带中的一个频带上发送和接收完之后，再换一个频带继续发送和接收，**我们把一个频带也叫作一个channel。** 这样从第一个channel到最后一个channel，我们就好像有了一个很宽的带宽。

然后再介绍一下本系统用的**扫频协议** 。

这里我们直接引用论文原文：

>Chronos must ensure both the WiFi transmitter and receiver hop synchronously between multiple WiFi frequency bands. Chronos achieves this using a frequency band hopping protocol driven by the transmitter. Before switching frequency bands (every 2-3 ms in our implementation), the transmitter issues a control packet that advertises the frequency of the next band to hop to. The receiver responds with an acknowledgment and switches to the advertised frequency. Once the acknowledgment is received, the transmitter switches frequency bands as well. As a fail-safe, transmitters and receivers revert to a default frequency band if they do not receive packets or acknowledgments from each other for a given time-out duration on any band.

有了足够的带宽之后我们就可以得到一个关于公式1-3的方程组。 如下所示：

![方程组](D:\yanjiang0216.github.io\_posts\方程组.png)              2-1                                                           

### 2.2我们如何解出一个系统的TOF值

我们可以看到方程组2-1是一个一元线性同余方程组。我们要解出其中的$\tau$ 就能达到目的。这里就要用到中国剩余定理。中国剩余定理说明了一元线性同余方程组有解的准则以及求解方法。此时我们用它就可以解出一个系统的TOF值。通解的形式如下图所示：

![中国剩余定理](D:\yanjiang0216.github.io\_posts\中国剩余定理.png)

## 3.处理误差

在计算TOF值的过程中，会有很多的误差产生。

###3.1 消除SFO和PDD（包检测延迟）的误差

首先SFO（采样频偏）是如何产生的？

SFO和PDD造成的都是斜率上的误差，如下图所示：

![SFO和PDD](D:\yanjiang0216.github.io\_posts\SFO和PDD.png)

我们从上图中可以看出SFO和PDD对正数序号的载波和负数序号的载波分别造成的正向的影响和负向的影响，但是恰好对0号载波没有造成影响，所以我们可以利用0载波进行计算。

**然而**，0号载波是不存在的，所以我们要用插值法补出0号载波的值。

至此，我们就解决了SFO和PDD造成的误差。

### 3.2 处理多径效应

下图的左侧就是多径效应的结果

![多径效应](D:\yanjiang0216.github.io\_posts\多径效应.png)

接收端在开始处理收到的信号时，信号已经是频域信号了， 此时我们再使用逆傅里叶变化，将时域信号转换成频域信号，但是各个channel的频率是不一样的 ，所以我们要用INDFT（逆不等间距傅里叶变换）形成multipath profile。

在multipath profile中第一个峰所对应的路径，经历的时间是最短的，即它就是我们的视距路径。**在这里我们对multipath profile 中其他路径进行抑制，只留下视距路径** ，进而我们可以得到视距路径上的时域信号，在经过一个傅里叶变换，我们可以得到频域信号，此时我们再把这个频域信号送入2-1方程组中，再通过中国剩余定理解出一个相对准确的TOF值。至此我们就可以得到系统的TOF值。

### 3.3 消除PLL Phase Offset（锁相环频差）和CFO造成误差

锁相环是用来产生载波频率的，接收端和发送端都有锁相环。锁相环在产生载波频率的时候，会有一个初始相位，这个是初始相位是多少是没法控制的，是随机产生的，这就造成了 PLL Phase Offset，锁相环在产生载波频率的时候，虽然发送端和接收端设置的是一样的，但是总是还有一定的误差，这样就造成CFO。下来我们看一下如何消除PLL Phase Offset 和 CFO。

PLL Phase Offset 造成误差用下面的公式表示：

$\phi _{i,0} ^{tx} - \phi _{i,0} ^{rx} $                          3-1

CFO造成的误差用下面的公式表示：

$f_{i,0} ^{tx} - f_{i,0} ^{rx}​$                          3-2

其中，i（channel 序号），0（0号载波），tx（发送端），rx（接收端）。

$CSI_{i,0} ^{rx} (t)=h_{i,0} e^{j2\pi (f_{i,0} ^{tx} - f_{i,0} ^{rx})+(\phi _{i,0} ^{tx} - \phi _{i,0} ^{rx} )}$                    3-3

公式3-3 算出来的是接收端的受PLL Phase Offset 和 CFO影响的CSI值。

chronos 采用扫频协议发送端和接收端互相发包，所以发送端也可以测得一个CSI值。

$CSI_{i,0} ^{tx} (t)=h_{i,0} e^{j2\pi (f_{i,0} ^{rx} - f_{i,0} ^{tx})+(\phi _{i,0} ^{rx} - \phi _{i,0} ^{tx} )}$                    3-4

公式3-4 算出来的是发送端受PLL Phase Offset 和CFO影响的CSI值。

然后我们将 发送端和接收端的CSI值相乘便得到下面的公式

$CSI_{i,0} ^{rx} (t)CSI_{i,0} ^{tx} (t) = h_{i,0} ^{2}$                                       3-5

可以看到相乘之后我们可以看到PLL Phase Offset 和CFO造成的误差就被抵消了，最后只剩下了$h_{i,0} ^{2}$ ，通过$h_{i,0} ^{2}$可以得到一个TOF，但是这个TOF值不能直接用，这个TOF值正好是正确的TOF的2倍。

在这里举个例子说明为什么是2倍，直接引用原文

![消除CFO的例子](D:\yanjiang0216.github.io\_posts\消除CFO的例子.png)

## 4. 如何进行定位

TOF值乘以光速就可以得到距离。但是再得到距离之后如何进行定位呢？

$|d_{ij} - d_{i^{'}j}| < l_{ii^{'}}^{ap}$

其中$d_{ij}$ 表示AP上第i根天线到client上第j根天线的距离。$l_{ii^{'}} ^{ap}$ 表示AP上第i根天线到第$i^{'}$ 根天线的距离，这个值我们是已知的。如下图所示：

![天线要满足三角不等式](D:\yanjiang0216.github.io\_posts\天线要满足三角不等式.png)

就是说我们算出来的距离必须满足三角不等式。但是由于各种误差我们算出来值很有可能满足不了这个三角不等式。那么我们现在就弱化这个三角不等式，使用另外一种方法対值进行筛选。

步骤如下：

1. 对所有测量值以窗口$\alpha$ 进行聚类。（$\alpha >l_{ii^{'}}^{ap}$）

2. 找出值最大的聚类C。

3. 列出下面这样一个规划：

   ![定位中使用的规划](D:\yanjiang0216.github.io\_posts\定位中使用的规划.png)

   最终解出用户机上的三根天线的坐标。

   ​

   ​























